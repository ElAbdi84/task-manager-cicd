name: CD - Deploy to AWS with Docker

on:
  push:
    branches: [main]
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:

# Ne dÃ©ployer que si la PR est mergÃ©e (pas juste fermÃ©e)
# ou si c'est un push direct sur main

env:
  AWS_REGION: us-east-1
  ENVIRONMENT_NAME: TaskManager
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  FRONTEND_IMAGE_NAME: taskmanager-frontend
  BACKEND_IMAGE_NAME: taskmanager-backend

jobs:
  # ==================== CHECK IF DEPLOYMENT NEEDED ====================
  check-deployment:
    name: Check if Deployment Needed
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Check deployment condition
        id: check
        run: |
          # Deploy si:
          # 1. Push direct sur main
          # 2. PR mergÃ©e 
          # 3. DÃ©clenchement manuel
          
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… Deployment triggered by push to main"
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.pull_request.merged }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… Deployment triggered by merged PR #${{ github.event.pull_request.number }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… Deployment triggered manually"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "â¸ï¸  Deployment skipped - PR was closed without merging"
          fi

  # ==================== BUILD & PUSH IMAGES ====================
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [check-deployment]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    outputs:
      frontend_image: ${{ steps.build-frontend.outputs.image }}
      backend_image: ${{ steps.build-backend.outputs.image }}
      ecr_registry: ${{ steps.login-ecr.outputs.registry }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get Frontend IP for build
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "Frontend IP: $FRONTEND_IP"

      - name: Build Frontend Docker Image
        id: build-frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ğŸ”¨ Building Frontend Docker image..."
          echo "Registry: $ECR_REGISTRY"
          echo "Image tag: $IMAGE_TAG"
          
          # Build image with build args
          docker build \
            -f frontend/Dockerfile \
            --build-arg REACT_APP_API_URL=http://${{ steps.get-ip.outputs.frontend_ip }}/api \
            -t $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:latest \
            ./frontend
          
          # Push to ECR
          echo "ğŸ“¤ Pushing Frontend image to ECR..."
          docker push $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:latest
          
          # Output image URL
          IMAGE_URL="$ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG"
          echo "image=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "âœ… Frontend image: $IMAGE_URL"
          
          # Debug: Verify the output
          cat $GITHUB_OUTPUT | grep "image="

      - name: Build Backend Docker Image
        id: build-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ğŸ”¨ Building Backend Docker image..."
          echo "Registry: $ECR_REGISTRY"
          echo "Image tag: $IMAGE_TAG"
          
          # Build image
          docker build \
            -f backend/Dockerfile \
            -t $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:latest \
            ./backend
          
          # Push to ECR
          echo "ğŸ“¤ Pushing Backend image to ECR..."
          docker push $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:latest
          
          # Output image URL
          IMAGE_URL="$ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG"
          echo "image=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "âœ… Backend image: $IMAGE_URL"
          
          # Debug: Verify the output
          cat $GITHUB_OUTPUT | grep "image="

      - name: Image Build Summary
        run: |
          echo "ğŸ“¦ ================================"
          echo "ğŸ“¦ DOCKER IMAGES BUILT"
          echo "ğŸ“¦ ================================"
          echo ""
          echo "Frontend: ${{ steps.build-frontend.outputs.image }}"
          echo "Backend: ${{ steps.build-backend.outputs.image }}"
          echo ""
          echo "Verifying outputs are set..."
          if [ -z "${{ steps.build-frontend.outputs.image }}" ]; then
            echo "âŒ ERROR: Frontend image output is empty!"
            exit 1
          fi
          if [ -z "${{ steps.build-backend.outputs.image }}" ]; then
            echo "âŒ ERROR: Backend image output is empty!"
            exit 1
          fi
          echo "âœ… All outputs are valid"

  # ==================== DEPLOY FRONTEND ====================
  deploy-frontend:
    name: Deploy Frontend Container
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
         
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        
      - name: Construct Image URLs
        id: image-urls
        run: |   
          # Get ECR registry from AWS account
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="$AWS_ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          
          # Construct image URLs
          FRONTEND_IMAGE="$ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}"
          BACKEND_IMAGE="$ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}"
          
          echo "frontend_image=$FRONTEND_IMAGE" >> $GITHUB_OUTPUT
          echo "backend_image=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          
          echo "ğŸ“¦ Image URLs:"
          echo "Frontend: $FRONTEND_IMAGE"
          echo "Backend: $BACKEND_IMAGE"

      - name: Get Frontend IP
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "âœ… Frontend IP: $FRONTEND_IP"

      - name: Setup SSH Key
        run: |
          echo "ğŸ”‘ Setting up SSH key..."
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Decode base64 key
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY_B64 }}" | base64 -d > ~/.ssh/task-manager-key.pem
          chmod 600 ~/.ssh/task-manager-key.pem
          
          # Validate key
          if ! grep -q "BEGIN RSA PRIVATE KEY" ~/.ssh/task-manager-key.pem; then
            echo "âŒ SSH key decode failure"
            exit 1
          fi
          
          # Add host to known_hosts
          ssh-keyscan -H ${{ steps.get-ip.outputs.frontend_ip }} >> ~/.ssh/known_hosts 2>/dev/null
          echo "âœ… SSH key configured"

      - name: Get Backend IP
        id: get-backend-ip
        run: |
          echo "ğŸ” Fetching Backend IP from CloudFormation..."
          BACKEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`BackendPrivateIP`].OutputValue' \
            --output text)
          echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT
          echo "âœ… Backend IP: $BACKEND_IP"

      - name: Deploy Frontend Container
        env:
          FRONTEND_IMAGE: ${{ steps.image-urls.outputs.frontend_image }}
          BACKEND_IP: ${{ steps.get-backend-ip.outputs.backend_ip }}
        run: |
          echo "ğŸš€ Deploying Frontend container..."
          echo "ğŸ“¦ Frontend Image: $FRONTEND_IMAGE"
          echo "ğŸ”— Backend IP: $BACKEND_IP"
          
          if [ -z "$FRONTEND_IMAGE" ]; then
            echo "âŒ Frontend image URL is empty!"
            exit 1
          fi
          
          ssh -i ~/.ssh/task-manager-key.pem \
            -o StrictHostKeyChecking=no \
            ec2-user@${{ steps.get-ip.outputs.frontend_ip }} bash << ENDSSH
            set -e
            
            echo "ğŸ” Logging into ECR..."
            aws ecr get-login-password --region us-east-1 | \
              sudo docker login --username AWS --password-stdin \$(echo "$FRONTEND_IMAGE" | cut -d'/' -f1)
            
            echo "ğŸ“¥ Pulling Frontend image: $FRONTEND_IMAGE"
            sudo docker pull $FRONTEND_IMAGE
            
            echo "ğŸ›‘ Stopping old container..."
            sudo docker rm -f taskmanager-frontend 2>/dev/null || true
            
            echo "ğŸš€ Starting new Frontend container..."
            sudo docker run -d \
              --name taskmanager-frontend \
              --restart unless-stopped \
              -p 3000:80 \
              $FRONTEND_IMAGE
            
            echo "â³ Waiting for container to be healthy..."
            for i in {1..30}; do
              if sudo docker ps | grep -q "healthy.*taskmanager-frontend"; then
                echo "âœ… Container is healthy!"
                break
              fi
              echo "Waiting... (\$i/30)"
              sleep 2
            done
            
            echo "ğŸ”„ Updating Nginx configuration with Backend IP: $BACKEND_IP"
            
            # Remove old configuration
            sudo rm -f /etc/nginx/conf.d/taskmanager.conf
            
            # Create new Nginx configuration
            sudo tee /etc/nginx/conf.d/taskmanager.conf > /dev/null << 'NGINX_EOF'
          upstream frontend {
              server localhost:3000;
          }
          
          upstream backend {
              server BACKEND_IP_PLACEHOLDER:5000;
          }
          
          server {
              listen 80 default_server;
              server_name _;
              
              # Frontend - Proxy to Docker container on port 3000
              location / {
                  proxy_pass http://frontend;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_cache_bypass \$http_upgrade;
              }
              
              # Backend API
              location /api/ {
                  proxy_pass http://backend/api/;
                  proxy_http_version 1.1;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_connect_timeout 60s;
                  proxy_send_timeout 60s;
                  proxy_read_timeout 60s;
              }
          }
          NGINX_EOF
            
            # Replace placeholder with actual backend IP
            sudo sed -i "s/BACKEND_IP_PLACEHOLDER/$BACKEND_IP/g" /etc/nginx/conf.d/taskmanager.conf
            
            echo "âœ… Nginx configuration updated"
            
            # Test and reload Nginx
            sudo nginx -t
            sudo systemctl reload nginx
            
            echo "âœ… Frontend container deployed!"
            sudo docker ps | grep taskmanager-frontend
            
            echo "ğŸ” Testing container directly..."
            curl -s http://localhost:3000 | head -20
            
            echo "ğŸ” Testing via Nginx..."
            curl -s http://localhost | head -20
          ENDSSH

      - name: Verify Frontend Deployment
        run: |
          echo "ğŸ” Verifying Frontend deployment..."
          sleep 10
          
          # Test direct access
          RESPONSE=$(curl -s http://${{ steps.get-ip.outputs.frontend_ip }})
          
          if echo "$RESPONSE" | grep -q "Task Manager\|React\|root"; then
            echo "âœ… Frontend is serving React application"
          else
            echo "âŒ Frontend response doesn't look like React app"
            echo "Response preview:"
            echo "$RESPONSE" | head -20
            exit 1
          fi
          
          # Check HTTP status
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ steps.get-ip.outputs.frontend_ip }})
          
          if [ "$STATUS" -eq 200 ]; then
            echo "âœ… Frontend is accessible (HTTP $STATUS)"
          else
            echo "âŒ Frontend returned HTTP $STATUS"
            exit 1
          fi

  # ==================== DEPLOY BACKEND ====================
  deploy-backend:
    name: Deploy Backend Container
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push, deploy-frontend]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get IPs
        id: get-ips
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          
          BACKEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`BackendPrivateIP`].OutputValue' \
            --output text)
          
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY_B64 }}" | base64 -d > ~/.ssh/task-manager-key.pem
          chmod 600 ~/.ssh/task-manager-key.pem
          ssh-keyscan -H ${{ steps.get-ips.outputs.frontend_ip }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Construct Image URLs
        id: image-urls
        run: |
          # Get ECR registry from AWS account
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="$AWS_ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          
          # Construct backend image URL
          BACKEND_IMAGE="$ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}"
          
          echo "backend_image=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Backend Image: $BACKEND_IMAGE"

      - name: Deploy Backend Container
        env:
          BACKEND_IMAGE: ${{ steps.image-urls.outputs.backend_image }}
          BACKEND_IP: ${{ steps.get-ips.outputs.backend_ip }}
          FRONTEND_IP: ${{ steps.get-ips.outputs.frontend_ip }}
        run: |
          echo "ğŸš€ Deploying Backend container..."
          echo "ğŸ“¦ Backend Image: $BACKEND_IMAGE"
          echo "ğŸ”— Backend IP: $BACKEND_IP"
          
          if [ -z "$BACKEND_IMAGE" ]; then
            echo "âŒ Backend image URL is empty!"
            exit 1
          fi
          
          # Copy SSH key to Frontend (bastion)
          scp -i ~/.ssh/task-manager-key.pem \
            ~/.ssh/task-manager-key.pem \
            ec2-user@$FRONTEND_IP:~/.ssh/
          
          # Deploy via Frontend to Backend
          ssh -i ~/.ssh/task-manager-key.pem \
            -o StrictHostKeyChecking=no \
            ec2-user@$FRONTEND_IP << ENDSSH
            set -e
            
            chmod 600 ~/.ssh/task-manager-key.pem
            
            # Deploy to Backend via SSH
            ssh -i ~/.ssh/task-manager-key.pem \
              -o StrictHostKeyChecking=no \
              ec2-user@$BACKEND_IP << 'BACKEND_EOF'
              set -e
              
              echo "ğŸ” Logging into ECR..."
              aws ecr get-login-password --region us-east-1 | \
                docker login --username AWS --password-stdin \$(echo "$BACKEND_IMAGE" | cut -d'/' -f1)
              
              echo "ğŸ“¥ Pulling Backend image: $BACKEND_IMAGE"
              docker pull $BACKEND_IMAGE
              
              echo "ğŸ›‘ Stopping old container..."
              docker rm -f taskmanager-backend 2>/dev/null || true
              
              echo "ğŸš€ Starting new Backend container..."
              docker run -d \
                --name taskmanager-backend \
                --restart unless-stopped \
                -p 5000:5000 \
                -e DB_HOST=localhost \
                -e DB_USER=taskuser \
                -e DB_PASSWORD=TaskManager2025! \
                -e DB_NAME=taskmanager \
                --network host \
                $BACKEND_IMAGE
              
              echo "âœ… Backend container deployed!"
              docker ps | grep taskmanager-backend
              
              # Wait for backend to start
              sleep 5
              
              # Test backend health
              curl -f http://localhost:5000/api/health || echo "âš ï¸ Backend health check failed"
          BACKEND_EOF
          ENDSSH

      - name: Verify Backend Deployment
        run: |
          echo "ğŸ” Verifying Backend deployment..."
          sleep 5
          
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            http://${{ steps.get-ips.outputs.frontend_ip }}/api/health)
          
          if [ "$STATUS" -eq 200 ]; then
            echo "âœ… Backend is healthy (HTTP $STATUS)"
          else
            echo "âš ï¸ Backend returned HTTP $STATUS"
          fi

  # ==================== DEPLOYMENT SUMMARY ====================
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push, deploy-frontend, deploy-backend]
    if: always() && needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Frontend IP
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT

      - name: Display Summary
        env:
          FRONTEND_IMAGE: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}
          BACKEND_IMAGE: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}
        run: |
          echo ""
          echo "ğŸ‰ ================================"
          echo "ğŸ‰ DEPLOYMENT COMPLETE"
          echo "ğŸ‰ ================================"
          echo ""
          echo "ğŸ“¦ Docker Images:"
          echo "   Frontend: $FRONTEND_IMAGE"
          echo "   Backend: $BACKEND_IMAGE"
          echo ""
          echo "ğŸŒ Application URLs:"
          echo "   Frontend: http://${{ steps.get-ip.outputs.frontend_ip }}"
          echo "   API Health: http://${{ steps.get-ip.outputs.frontend_ip }}/api/health"
          echo "   API Tasks: http://${{ steps.get-ip.outputs.frontend_ip }}/api/tasks"
          echo ""
          echo "ğŸ“Š Deployment Status:"
          echo "   Build & Push: ${{ needs.build-and-push.result }}"
          echo "   Frontend Deploy: ${{ needs.deploy-frontend.result }}"
          echo "   Backend Deploy: ${{ needs.deploy-backend.result }}"
          echo ""
          
          if [[ "${{ needs.deploy-frontend.result }}" == "success" ]] && \
             [[ "${{ needs.deploy-backend.result }}" == "success" ]]; then
            echo "âœ… All deployments successful!"
          else
            echo "âš ï¸ Some deployments failed. Check logs above."
          fi