name: CD - Deploy to AWS with Docker

on:
  push:
    branches: [main]
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:

# Ne d√©ployer que si la PR est merg√©e (pas juste ferm√©e)
# ou si c'est un push direct sur main

env:
  AWS_REGION: us-east-1
  ENVIRONMENT_NAME: TaskManager
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  FRONTEND_IMAGE_NAME: taskmanager-frontend
  BACKEND_IMAGE_NAME: taskmanager-backend

jobs:
  # ==================== CHECK IF DEPLOYMENT NEEDED ====================
  check-deployment:
    name: Check if Deployment Needed
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Check deployment condition
        id: check
        run: |
          # Deploy si:
          # 1. Push direct sur main
          # 2. PR merg√©e (pas juste ferm√©e)
          # 3. D√©clenchement manuel
          
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment triggered by push to main"
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.pull_request.merged }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment triggered by merged PR #${{ github.event.pull_request.number }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment triggered manually"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "‚è∏Ô∏è  Deployment skipped - PR was closed without merging"
          fi

  # ==================== BUILD & PUSH IMAGES ====================
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [check-deployment]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    outputs:
      frontend_image: ${{ steps.build-frontend.outputs.image }}
      backend_image: ${{ steps.build-backend.outputs.image }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get Frontend IP for build
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "Frontend IP: $FRONTEND_IP"

      - name: Build Frontend Docker Image
        id: build-frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üî® Building Frontend Docker image..."
          echo "Registry: $ECR_REGISTRY"
          echo "Image tag: $IMAGE_TAG"
          
          # Build image with build args
          docker build \
            -f frontend/Dockerfile \
            --build-arg REACT_APP_API_URL=http://${{ steps.get-ip.outputs.frontend_ip }}/api \
            -t $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:latest \
            ./frontend
          
          # Push to ECR
          echo "üì§ Pushing Frontend image to ECR..."
          docker push $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:latest
          
          # Output image URL
          IMAGE_URL="$ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG"
          echo "image=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend image: $IMAGE_URL"
          
          # Debug: Verify the output
          cat $GITHUB_OUTPUT | grep "image="

      - name: Build Backend Docker Image
        id: build-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üî® Building Backend Docker image..."
          echo "Registry: $ECR_REGISTRY"
          echo "Image tag: $IMAGE_TAG"
          
          # Build image
          docker build \
            -f backend/Dockerfile \
            -t $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:latest \
            ./backend
          
          # Push to ECR
          echo "üì§ Pushing Backend image to ECR..."
          docker push $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:latest
          
          # Output image URL
          IMAGE_URL="$ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG"
          echo "image=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Backend image: $IMAGE_URL"
          
          # Debug: Verify the output
          cat $GITHUB_OUTPUT | grep "image="

      - name: Image Build Summary
        run: |
          echo "üì¶ ================================"
          echo "üì¶ DOCKER IMAGES BUILT"
          echo "üì¶ ================================"
          echo ""
          echo "Frontend: ${{ steps.build-frontend.outputs.image }}"
          echo "Backend: ${{ steps.build-backend.outputs.image }}"

  # ==================== DEPLOY FRONTEND ====================
  deploy-frontend:
    name: Deploy Frontend Container
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get Frontend IP
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend IP: $FRONTEND_IP"

      - name: Setup SSH Key
        run: |
          echo "üîë Setting up SSH key..."
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Decode base64 key
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY_B64 }}" | base64 -d > ~/.ssh/task-manager-key.pem
          chmod 600 ~/.ssh/task-manager-key.pem
          
          # Validate key
          if ! grep -q "BEGIN RSA PRIVATE KEY" ~/.ssh/task-manager-key.pem; then
            echo "‚ùå SSH key decode failure"
            exit 1
          fi
          
          # Add host to known_hosts
          ssh-keyscan -H ${{ steps.get-ip.outputs.frontend_ip }} >> ~/.ssh/known_hosts 2>/dev/null
          echo "‚úÖ SSH key configured"

      - name: Debug - Verify Image URLs
        run: |
          echo "üîç Debugging Image URLs..."
          echo "Frontend Image Output: ${{ needs.build-and-push.outputs.frontend_image }}"
          echo "Backend Image Output: ${{ needs.build-and-push.outputs.backend_image }}"
          
          if [ -z "${{ needs.build-and-push.outputs.frontend_image }}" ]; then
            echo "‚ùå Frontend image is empty!"
            exit 1
          fi
          
          if [ -z "${{ needs.build-and-push.outputs.backend_image }}" ]; then
            echo "‚ùå Backend image is empty!"
            exit 1
          fi
          
          echo "‚úÖ Both image URLs are valid"

      - name: Get Backend IP
        id: get-backend-ip
        run: |
          echo "üîç Fetching Backend IP from CloudFormation..."
          BACKEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`BackendPrivateIP`].OutputValue' \
            --output text)
          echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ Backend IP: $BACKEND_IP"

      - name: Deploy Frontend Container
        env:
          FRONTEND_IMAGE: ${{ needs.build-and-push.outputs.frontend_image }}
          BACKEND_IP: ${{ steps.get-backend-ip.outputs.backend_ip }}
          ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üöÄ Deploying Frontend container..."
          echo "Frontend Image from output: $FRONTEND_IMAGE"
          echo "Backend IP will be: $BACKEND_IP"
          
          # Fallback si l'image est vide
          if [ -z "$FRONTEND_IMAGE" ]; then
            FRONTEND_IMAGE="${ECR_REGISTRY}/${{ env.FRONTEND_IMAGE_NAME }}:${IMAGE_TAG}"
            echo "‚ö†Ô∏è Using fallback image: $FRONTEND_IMAGE"
          fi
          
          echo "üì¶ Final Frontend Image: $FRONTEND_IMAGE"
          
          ssh -i ~/.ssh/task-manager-key.pem \
            -o StrictHostKeyChecking=no \
            ec2-user@${{ steps.get-ip.outputs.frontend_ip }} << ENDSSH
            set -e
            
            echo "üîê Logging into ECR..."
            aws ecr get-login-password --region us-east-1 | \
              docker login --username AWS --password-stdin ${ECR_REGISTRY}
            
            echo "üì• Pulling Frontend image: ${FRONTEND_IMAGE}"
            docker pull ${FRONTEND_IMAGE}
            
            echo "üõë Stopping old container..."
            docker stop taskmanager-frontend 2>/dev/null || true
            docker rm taskmanager-frontend 2>/dev/null || true
            
            echo "üöÄ Starting new Frontend container..."
            docker run -d \
              --name taskmanager-frontend \
              --restart unless-stopped \
              -p 3000:80 \
              ${FRONTEND_IMAGE}
            
            echo "üîÑ Updating Nginx configuration with Backend IP: ${BACKEND_IP}"
            sudo tee /etc/nginx/conf.d/taskmanager.conf > /dev/null << 'NGINX_EOF'
            upstream frontend {
                server localhost:3000;
            }
            
            upstream backend {
                server BACKEND_IP_PLACEHOLDER:5000;
            }
            
            server {
                listen 80;
                server_name _;
                
                # Frontend
                location / {
                    proxy_pass http://frontend;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_cache_bypass \$http_upgrade;
                }
                
                # Backend API - IP dynamique r√©cup√©r√©e depuis CloudFormation
                location /api/ {
                    proxy_pass http://backend/api/;
                    proxy_http_version 1.1;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_connect_timeout 60s;
                    proxy_send_timeout 60s;
                    proxy_read_timeout 60s;
                }
            }
            NGINX_EOF
            
            # Replace placeholder with actual backend IP
            sudo sed -i "s/BACKEND_IP_PLACEHOLDER/${BACKEND_IP}/g" /etc/nginx/conf.d/taskmanager.conf
            
            echo "‚úÖ Nginx configuration updated with Backend IP: ${BACKEND_IP}"
            
            sudo nginx -t
            sudo systemctl reload nginx
            
            echo "‚úÖ Frontend container deployed!"
            docker ps | grep taskmanager-frontend
          ENDSSH

      - name: Verify Frontend Deployment
        run: |
          echo "üîç Verifying Frontend deployment..."
          sleep 10
          
          STATUS=\$(curl -s -o /dev/null -w "%{http_code}" http://${{ steps.get-ip.outputs.frontend_ip }})
          
          if [ "$STATUS" -eq 200 ]; then
            echo "‚úÖ Frontend is accessible (HTTP $STATUS)"
          else
            echo "‚ùå Frontend returned HTTP $STATUS"
            exit 1
          fi

  # ==================== DEPLOY BACKEND ====================
  deploy-backend:
    name: Deploy Backend Container
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push, deploy-frontend]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get IPs
        id: get-ips
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          
          BACKEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`BackendPrivateIP`].OutputValue' \
            --output text)
          
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY_B64 }}" | base64 -d > ~/.ssh/task-manager-key.pem
          chmod 600 ~/.ssh/task-manager-key.pem
          ssh-keyscan -H ${{ steps.get-ips.outputs.frontend_ip }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Deploy Backend Container
        env:
          BACKEND_IMAGE: ${{ needs.build-and-push.outputs.backend_image }}
          BACKEND_IP: ${{ steps.get-ips.outputs.backend_ip }}
          FRONTEND_IP: ${{ steps.get-ips.outputs.frontend_ip }}
          ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üöÄ Deploying Backend container..."
          echo "Backend Image from output: $BACKEND_IMAGE"
          echo "Backend IP: $BACKEND_IP"
          
          # Fallback si l'image est vide
          if [ -z "$BACKEND_IMAGE" ]; then
            BACKEND_IMAGE="${ECR_REGISTRY}/${{ env.BACKEND_IMAGE_NAME }}:${IMAGE_TAG}"
            echo "‚ö†Ô∏è Using fallback image: $BACKEND_IMAGE"
          fi
          
          echo "üì¶ Final Backend Image: $BACKEND_IMAGE"
          
          # Copy SSH key to Frontend (bastion)
          scp -i ~/.ssh/task-manager-key.pem \
            ~/.ssh/task-manager-key.pem \
            ec2-user@$FRONTEND_IP:~/.ssh/
          
          # Deploy via Frontend to Backend
          ssh -i ~/.ssh/task-manager-key.pem \
            -o StrictHostKeyChecking=no \
            ec2-user@$FRONTEND_IP << ENDSSH
            set -e
            
            chmod 600 ~/.ssh/task-manager-key.pem
            
            # Deploy to Backend via SSH
            ssh -i ~/.ssh/task-manager-key.pem \
              -o StrictHostKeyChecking=no \
              ec2-user@${BACKEND_IP} << 'BACKEND_EOF'
              set -e
              
              echo "üîê Logging into ECR..."
              aws ecr get-login-password --region us-east-1 | \
                docker login --username AWS --password-stdin ${ECR_REGISTRY}
              
              echo "üì• Pulling Backend image: ${BACKEND_IMAGE}"
              docker pull ${BACKEND_IMAGE}
              
              echo "üõë Stopping old container..."
              docker stop taskmanager-backend 2>/dev/null || true
              docker rm taskmanager-backend 2>/dev/null || true
              
              echo "üöÄ Starting new Backend container..."
              docker run -d \
                --name taskmanager-backend \
                --restart unless-stopped \
                -p 5000:5000 \
                -e DB_HOST=localhost \
                -e DB_USER=taskuser \
                -e DB_PASSWORD=TaskManager2025! \
                -e DB_NAME=taskmanager \
                --network host \
                ${BACKEND_IMAGE}
              
              echo "‚úÖ Backend container deployed!"
              docker ps | grep taskmanager-backend
              
              # Wait for backend to start
              sleep 5
              
              # Test backend health
              curl -f http://localhost:5000/api/health || echo "‚ö†Ô∏è Backend health check failed"
          BACKEND_EOF
          ENDSSH

      - name: Verify Backend Deployment
        run: |
          echo "üîç Verifying Backend deployment..."
          sleep 5
          
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            http://${{ steps.get-ips.outputs.frontend_ip }}/api/health)
          
          if [ "$STATUS" -eq 200 ]; then
            echo "‚úÖ Backend is healthy (HTTP $STATUS)"
          else
            echo "‚ö†Ô∏è Backend returned HTTP $STATUS"
          fi

  # ==================== DEPLOYMENT SUMMARY ====================
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push, deploy-frontend, deploy-backend]
    if: always() && needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Frontend IP
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT

      - name: Display Summary
        run: |
          echo ""
          echo "üéâ ================================"
          echo "üéâ DEPLOYMENT COMPLETE"
          echo "üéâ ================================"
          echo ""
          echo "üì¶ Docker Images:"
          echo "   Frontend: ${{ needs.build-and-push.outputs.frontend_image }}"
          echo "   Backend: ${{ needs.build-and-push.outputs.backend_image }}"
          echo ""
          echo "üåê Application URLs:"
          echo "   Frontend: http://${{ steps.get-ip.outputs.frontend_ip }}"
          echo "   API Health: http://${{ steps.get-ip.outputs.frontend_ip }}/api/health"
          echo "   API Tasks: http://${{ steps.get-ip.outputs.frontend_ip }}/api/tasks"
          echo ""
          echo "üìä Deployment Status:"
          echo "   Build & Push: ${{ needs.build-and-push.result }}"
          echo "   Frontend Deploy: ${{ needs.deploy-frontend.result }}"
          echo "   Backend Deploy: ${{ needs.deploy-backend.result }}"
          echo ""
          
          if [[ "${{ needs.deploy-frontend.result }}" == "success" ]] && \
             [[ "${{ needs.deploy-backend.result }}" == "success" ]]; then
            echo "‚úÖ All deployments successful!"
          else
            echo "‚ö†Ô∏è Some deployments failed. Check logs above."
          fi