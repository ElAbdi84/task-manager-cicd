name: CD - Deploy to AWS with Docker

on:
  push:
    branches: [main]
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:

# Ne d√©ployer que si la PR est merg√©e (pas juste ferm√©e)
# ou si c'est un push direct sur main

env:
  AWS_REGION: us-east-1
  ENVIRONMENT_NAME: TaskManager
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  FRONTEND_IMAGE_NAME: taskmanager-frontend
  BACKEND_IMAGE_NAME: taskmanager-backend

jobs:
  # ==================== CHECK IF DEPLOYMENT NEEDED ====================
  check-deployment:
    name: Check if Deployment Needed
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Check deployment condition
        id: check
        run: |
          # Deploy si:
          # 1. Push direct sur main
          # 2. PR merg√©e (pas juste ferm√©e)
          # 3. D√©clenchement manuel
          
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment triggered by push to main"
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.pull_request.merged }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment triggered by merged PR #${{ github.event.pull_request.number }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment triggered manually"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "‚è∏Ô∏è  Deployment skipped - PR was closed without merging"
          fi

  # ==================== BUILD & PUSH IMAGES ====================
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [check-deployment]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    outputs:
      frontend_image: ${{ steps.build-frontend.outputs.image }}
      backend_image: ${{ steps.build-backend.outputs.image }}
      ecr_registry: ${{ steps.login-ecr.outputs.registry }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get Frontend IP for build
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "Frontend IP: $FRONTEND_IP"

      - name: Build Frontend Docker Image
        id: build-frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üî® Building Frontend Docker image..."
          echo "Registry: $ECR_REGISTRY"
          echo "Image tag: $IMAGE_TAG"
          
          # Build image with build args
          docker build \
            -f frontend/Dockerfile \
            --build-arg REACT_APP_API_URL=http://${{ steps.get-ip.outputs.frontend_ip }}/api \
            -t $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:latest \
            ./frontend
          
          # Push to ECR
          echo "üì§ Pushing Frontend image to ECR..."
          docker push $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:latest
          
          # Output image URL
          IMAGE_URL="$ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG"
          echo "image=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend image: $IMAGE_URL"
          
          # Debug: Verify the output
          cat $GITHUB_OUTPUT | grep "image="

      - name: Build Backend Docker Image
        id: build-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üî® Building Backend Docker image..."
          echo "Registry: $ECR_REGISTRY"
          echo "Image tag: $IMAGE_TAG"
          
          # Build image
          docker build \
            -f backend/Dockerfile \
            -t $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:latest \
            ./backend
          
          # Push to ECR
          echo "üì§ Pushing Backend image to ECR..."
          docker push $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:latest
          
          # Output image URL
          IMAGE_URL="$ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG"
          echo "image=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Backend image: $IMAGE_URL"
          
          # Debug: Verify the output
          cat $GITHUB_OUTPUT | grep "image="

      - name: Image Build Summary
        run: |
          echo "üì¶ ================================"
          echo "üì¶ DOCKER IMAGES BUILT"
          echo "üì¶ ================================"
          echo ""
          echo "Frontend: ${{ steps.build-frontend.outputs.image }}"
          echo "Backend: ${{ steps.build-backend.outputs.image }}"
          echo ""
          echo "Verifying outputs are set..."
          if [ -z "${{ steps.build-frontend.outputs.image }}" ]; then
            echo "‚ùå ERROR: Frontend image output is empty!"
            exit 1
          fi
          if [ -z "${{ steps.build-backend.outputs.image }}" ]; then
            echo "‚ùå ERROR: Backend image output is empty!"
            exit 1
          fi
          echo "‚úÖ All outputs are valid"

  # ==================== DEPLOY FRONTEND ====================
  deploy-frontend:
    name: Deploy Frontend Container
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Construct Image URLs
        id: image-urls
        run: |
          # Get ECR registry from AWS account
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="$AWS_ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          
          # Construct image URLs
          FRONTEND_IMAGE="$ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}"
          BACKEND_IMAGE="$ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}"
          
          echo "frontend_image=$FRONTEND_IMAGE" >> $GITHUB_OUTPUT
          echo "backend_image=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          
          echo "üì¶ Image URLs:"
          echo "Frontend: $FRONTEND_IMAGE"
          echo "Backend: $BACKEND_IMAGE"

      - name: Get Frontend IP
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend IP: $FRONTEND_IP"

      - name: Setup SSH Key
        run: |
          echo "üîë Setting up SSH key..."
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Decode base64 key
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY_B64 }}" | base64 -d > ~/.ssh/task-manager-key.pem
          chmod 600 ~/.ssh/task-manager-key.pem
          
          # Validate key
          if ! grep -q "BEGIN RSA PRIVATE KEY" ~/.ssh/task-manager-key.pem; then
            echo "‚ùå SSH key decode failure"
            exit 1
          fi
          
          # Add host to known_hosts
          ssh-keyscan -H ${{ steps.get-ip.outputs.frontend_ip }} >> ~/.ssh/known_hosts 2>/dev/null
          echo "‚úÖ SSH key configured"

      - name: Debug - Verify Image URLs
        run: |
          echo "üîç Debugging Image URLs..."
          echo "Step output - Frontend: ${{ steps.build-frontend.outputs.image }}"
          echo "Step output - Backend: ${{ steps.build-backend.outputs.image }}"
          echo "Job output - Frontend: ${{ needs.build-and-push.outputs.frontend_image }}"
          echo "Job output - Backend: ${{ needs.build-and-push.outputs.backend_image }}"
          echo ""
          echo "Building image URLs from env vars..."
          FRONTEND_IMG="${{ needs.build-and-push.outputs.ecr_registry }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}"
          BACKEND_IMG="${{ needs.build-and-push.outputs.ecr_registry }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}"
          echo "Constructed Frontend: $FRONTEND_IMG"
          echo "Constructed Backend: $BACKEND_IMG"
          
          # Use job outputs if available, otherwise construct from env
          if [ ! -z "${{ needs.build-and-push.outputs.frontend_image }}" ]; then
            echo "‚úÖ Using job output for frontend"
          else
            echo "‚ö†Ô∏è  Job output empty, will use constructed URL"
          fi

      - name: Get Backend IP
        id: get-backend-ip
        run: |
          echo "üîç Fetching Backend IP from CloudFormation..."
          BACKEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`BackendPrivateIP`].OutputValue' \
            --output text)
          echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ Backend IP: $BACKEND_IP"

      - name: Deploy Frontend Container
        env:
          FRONTEND_IMAGE: ${{ steps.image-urls.outputs.frontend_image }}
          BACKEND_IP: ${{ steps.get-backend-ip.outputs.backend_ip }}
        run: |
          echo "üöÄ Deploying Frontend container..."
          echo "üì¶ Frontend Image: $FRONTEND_IMAGE"
          echo "üîó Backend IP: $BACKEND_IP"
          
          if [ -z "$FRONTEND_IMAGE" ]; then
            echo "‚ùå Frontend image URL is empty!"
            exit 1
          fi
          
          # Pass variables to SSH session
          ssh -i ~/.ssh/task-manager-key.pem \
            -o StrictHostKeyChecking=no \
            ec2-user@${{ steps.get-ip.outputs.frontend_ip }} \
            bash -s "$FRONTEND_IMAGE" "$BACKEND_IP" << 'ENDSSH'
            set -e
            
            # Receive arguments
            FRONTEND_IMAGE="$1"
            BACKEND_IP="$2"
            
            echo "üîê Logging into ECR..."
            aws ecr get-login-password --region us-east-1 | \
              docker login --username AWS --password-stdin $(echo "$FRONTEND_IMAGE" | cut -d'/' -f1)
            
            echo "üì• Pulling Frontend image: $FRONTEND_IMAGE"
            docker pull $FRONTEND_IMAGE
            
            echo "üõë Stopping old container..."
            docker stop taskmanager-frontend 2>/dev/null || true
            docker rm taskmanager-frontend 2>/dev/null || true
            
            echo "üöÄ Starting new Frontend container..."
            docker run -d \
              --name taskmanager-frontend \
              --restart unless-stopped \
              -p 3000:80 \
              $FRONTEND_IMAGE
            
            # Wait for container to be healthy
            echo "‚è≥ Waiting for container to be healthy..."
            sleep 5
            
            # Verify container is running
            if ! docker ps | grep -q taskmanager-frontend; then
              echo "‚ùå Container failed to start"
              docker logs taskmanager-frontend
              exit 1
            fi
            
            echo "üîÑ Updating Nginx configuration with Backend IP: $BACKEND_IP"
            
            # Remove default HTML that interferes
            sudo rm -f /var/www/html/index.html
            
            # Disable default Nginx configs
            sudo mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.conf.disabled 2>/dev/null || true
            sudo mv /etc/nginx/sites-enabled/default /etc/nginx/sites-enabled/default.disabled 2>/dev/null || true
            
            # Backup and clean main nginx.conf
            if [ ! -f /etc/nginx/nginx.conf.original ]; then
              sudo cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.original
            fi
            
            # Create a clean nginx.conf without any server blocks
            sudo bash -c 'cat > /etc/nginx/nginx.conf' << 'NGINX_MAIN_EOF'
           user nginx;
           worker_processes auto;
          error_log /var/log/nginx/error.log notice;
           pid /run/nginx.pid;

          events {
            worker_connections 1024;
            }

          http {
           include /etc/nginx/mime.types;
          default_type application/octet-stream;

          log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

          access_log /var/log/nginx/access.log main;

          sendfile on;
          tcp_nopush on;
          keepalive_timeout 65;
          types_hash_max_size 4096;

          # Include all conf files from conf.d
          include /etc/nginx/conf.d/*.conf;
          }
          NGINX_MAIN_EOF
            
            # Create the application-specific config
            sudo bash -c "cat > /etc/nginx/conf.d/taskmanager.conf" <<EOF
           upstream frontend_app {
            server localhost:3000;
          }

          upstream backend_app {
          server ${BACKEND_IP}:5000;
            }

          server {
           listen 80 default_server;
           listen [::]:80 default_server;
             server_name _;

            location / {
           proxy_pass http://frontend_app;
           proxy_http_version 1.1;
           proxy_set_header Upgrade \$http_upgrade;
           proxy_set_header Connection 'upgrade';
           proxy_set_header Host \$host;
           proxy_cache_bypass \$http_upgrade;
          proxy_set_header X-Real-IP \$remote_addr;
          proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto \$scheme;
          }

          location /api/ {
          proxy_pass http://backend_app/api/;
          proxy_http_version 1.1;
          proxy_set_header Host \$host;
          proxy_set_header X-Real-IP \$remote_addr;
          proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto \$scheme;
          proxy_connect_timeout 60s;
          proxy_send_timeout 60s;
          proxy_read_timeout 60s;
           }
            }
           EOF
            
            echo "‚úÖ Nginx configuration created"
            
            # Show the final config for debugging
            echo "üìÑ Final Nginx configuration:"
            sudo cat /etc/nginx/conf.d/taskmanager.conf
            
            echo "üß™ Testing Nginx configuration..."
            if ! sudo nginx -t; then
              echo "‚ùå Nginx test failed"
              echo "=== Main nginx.conf ==="
              sudo cat /etc/nginx/nginx.conf
              echo "=== taskmanager.conf ==="
              sudo cat /etc/nginx/conf.d/taskmanager.conf
              exit 1
            fi
            
            echo "üîÑ Reloading Nginx..."
            sudo systemctl reload nginx
            
            sleep 3
            
            echo "‚úÖ Deployment complete!"
            echo "  Container: $(docker ps --filter name=taskmanager-frontend --format '{{.ID}}')"
            echo "  Frontend :3000: $(curl -s -o /dev/null -w '%{http_code}' http://localhost:3000)"
            echo "  Nginx proxy: $(curl -s -o /dev/null -w '%{http_code}' http://localhost)"
          ENDSSH

      - name: Verify Frontend Deployment
        run: |
          echo "üîç Verifying Frontend deployment..."
          sleep 10
          
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ steps.get-ip.outputs.frontend_ip }})
          
          if [ "$STATUS" -eq 200 ]; then
            echo "‚úÖ Frontend is accessible (HTTP $STATUS)"
          else
            echo "‚ùå Frontend returned HTTP $STATUS"
            exit 1
          fi

  # ==================== DEPLOY BACKEND ====================
  deploy-backend:
    name: Deploy Backend Container
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push, deploy-frontend]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get IPs
        id: get-ips
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          
          BACKEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`BackendPrivateIP`].OutputValue' \
            --output text)
          
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY_B64 }}" | base64 -d > ~/.ssh/task-manager-key.pem
          chmod 600 ~/.ssh/task-manager-key.pem
          ssh-keyscan -H ${{ steps.get-ips.outputs.frontend_ip }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Construct Image URLs
        id: image-urls
        run: |
          # Get ECR registry from AWS account
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="$AWS_ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          
          # Construct backend image URL
          BACKEND_IMAGE="$ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}"
          
          echo "backend_image=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          echo "üì¶ Backend Image: $BACKEND_IMAGE"

      - name: Deploy Backend Container
        env:
          BACKEND_IMAGE: ${{ steps.image-urls.outputs.backend_image }}
          BACKEND_IP: ${{ steps.get-ips.outputs.backend_ip }}
          FRONTEND_IP: ${{ steps.get-ips.outputs.frontend_ip }}
        run: |
          echo "üöÄ Deploying Backend container..."
          echo "üì¶ Backend Image: $BACKEND_IMAGE"
          echo "üîó Backend IP: $BACKEND_IP"
          
          if [ -z "$BACKEND_IMAGE" ]; then
            echo "‚ùå Backend image URL is empty!"
            exit 1
          fi
          
          # Copy SSH key to Frontend (bastion)
          scp -i ~/.ssh/task-manager-key.pem \
            ~/.ssh/task-manager-key.pem \
            ec2-user@$FRONTEND_IP:~/.ssh/
          
          # Deploy via Frontend to Backend
          ssh -i ~/.ssh/task-manager-key.pem \
            -o StrictHostKeyChecking=no \
            ec2-user@$FRONTEND_IP << ENDSSH
            set -e
            
            chmod 600 ~/.ssh/task-manager-key.pem
            
            # Deploy to Backend via SSH
            ssh -i ~/.ssh/task-manager-key.pem \
              -o StrictHostKeyChecking=no \
              ec2-user@$BACKEND_IP << 'BACKEND_EOF'
              set -e
              
              echo "üîê Logging into ECR..."
              aws ecr get-login-password --region us-east-1 | \
                docker login --username AWS --password-stdin \$(echo "$BACKEND_IMAGE" | cut -d'/' -f1)
              
              echo "üì• Pulling Backend image: $BACKEND_IMAGE"
              docker pull $BACKEND_IMAGE
              
              echo "üõë Stopping old container..."
              docker stop taskmanager-backend 2>/dev/null || true
              docker rm taskmanager-backend 2>/dev/null || true
              
              echo "üöÄ Starting new Backend container..."
              docker run -d \
                --name taskmanager-backend \
                --restart unless-stopped \
                -p 5000:5000 \
                -e DB_HOST=localhost \
                -e DB_USER=taskuser \
                -e DB_PASSWORD=TaskManager2025! \
                -e DB_NAME=taskmanager \
                --network host \
                $BACKEND_IMAGE
              
              echo "‚è≥ Waiting for backend to start..."
              sleep 10
              
              # Verify container is running
              if ! docker ps | grep -q taskmanager-backend; then
                echo "‚ùå Backend container failed to start"
                docker logs taskmanager-backend
                exit 1
              fi
              
              echo "‚úÖ Backend container deployed!"
              docker ps | grep taskmanager-backend
              
              # Test backend health locally
              echo "üß™ Testing backend health..."
              HEALTH_STATUS=\$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/api/health || echo "000")
              echo "Backend health check status: \$HEALTH_STATUS"
              
              if [ "\$HEALTH_STATUS" = "200" ]; then
                echo "‚úÖ Backend is healthy!"
                curl -s http://localhost:5000/api/health | head -5
              else
                echo "‚ö†Ô∏è Backend health check failed (HTTP \$HEALTH_STATUS)"
                echo "Container logs:"
                docker logs taskmanager-backend | tail -20
              fi
          BACKEND_EOF
          ENDSSH

      - name: Verify Backend Deployment
        run: |
          echo "üîç Verifying Backend deployment..."
          sleep 5
          
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            http://${{ steps.get-ips.outputs.frontend_ip }}/api/health)
          
          if [ "$STATUS" -eq 200 ]; then
            echo "‚úÖ Backend is healthy (HTTP $STATUS)"
          else
            echo "‚ö†Ô∏è Backend returned HTTP $STATUS"
          fi

  # ==================== DEPLOYMENT SUMMARY ====================
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push, deploy-frontend, deploy-backend]
    if: always() && needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Frontend IP
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT

      - name: Display Summary
        env:
          FRONTEND_IMAGE: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}
          BACKEND_IMAGE: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}
        run: |
          echo ""
          echo "üéâ ================================"
          echo "üéâ DEPLOYMENT COMPLETE"
          echo "üéâ ================================"
          echo ""
          echo "üì¶ Docker Images:"
          echo "   Frontend: $FRONTEND_IMAGE"
          echo "   Backend: $BACKEND_IMAGE"
          echo ""
          echo "üåê Application URLs:"
          echo "   Frontend: http://${{ steps.get-ip.outputs.frontend_ip }}"
          echo "   API Health: http://${{ steps.get-ip.outputs.frontend_ip }}/api/health"
          echo "   API Tasks: http://${{ steps.get-ip.outputs.frontend_ip }}/api/tasks"
          echo ""
          echo "üìä Deployment Status:"
          echo "   Build & Push: ${{ needs.build-and-push.result }}"
          echo "   Frontend Deploy: ${{ needs.deploy-frontend.result }}"
          echo "   Backend Deploy: ${{ needs.deploy-backend.result }}"
          echo ""
          
          if [[ "${{ needs.deploy-frontend.result }}" == "success" ]] && \
             [[ "${{ needs.deploy-backend.result }}" == "success" ]]; then
            echo "‚úÖ All deployments successful!"
          else
            echo "‚ö†Ô∏è Some deployments failed. Check logs above."
          fi