name: CD - Deploy to AWS with Docker

on:
  push:
    branches: [main]
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:

# Ne dÃ©ployer que si la PR est mergÃ©e (pas juste fermÃ©e)
# ou si c'est un push direct sur main

env:
  AWS_REGION: us-east-1
  ENVIRONMENT_NAME: TaskManager
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  FRONTEND_IMAGE_NAME: taskmanager-frontend
  BACKEND_IMAGE_NAME: taskmanager-backend

jobs:
  # ==================== CHECK IF DEPLOYMENT NEEDED ====================
  check-deployment:
    name: Check if Deployment Needed
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Check deployment condition
        id: check
        run: |
          # Deploy si:
          # 1. Push direct sur main
          # 2. PR mergÃ©e (pas juste fermÃ©e)
          # 3. DÃ©clenchement manuel
          
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… Deployment triggered by push to main"
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.pull_request.merged }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… Deployment triggered by merged PR #${{ github.event.pull_request.number }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… Deployment triggered manually"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "â¸ï¸  Deployment skipped - PR was closed without merging"
          fi

  # ==================== BUILD & PUSH IMAGES ====================
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [check-deployment]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    outputs:
      frontend_image: ${{ steps.build-frontend.outputs.image }}
      backend_image: ${{ steps.build-backend.outputs.image }}
      ecr_registry: ${{ steps.login-ecr.outputs.registry }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get Frontend IP for build
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "Frontend IP: $FRONTEND_IP"

      - name: Build Frontend Docker Image
        id: build-frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ğŸ”¨ Building Frontend Docker image..."
          echo "Registry: $ECR_REGISTRY"
          echo "Image tag: $IMAGE_TAG"
          
          # Build image with build args
          docker build \
            -f frontend/Dockerfile \
            --build-arg REACT_APP_API_URL=http://${{ steps.get-ip.outputs.frontend_ip }}/api \
            -t $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:latest \
            ./frontend
          
          # Push to ECR
          echo "ğŸ“¤ Pushing Frontend image to ECR..."
          docker push $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:latest
          
          # Output image URL
          IMAGE_URL="$ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG"
          echo "image=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "âœ… Frontend image: $IMAGE_URL"
          
          # Debug: Verify the output
          cat $GITHUB_OUTPUT | grep "image="

      - name: Build Backend Docker Image
        id: build-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ğŸ”¨ Building Backend Docker image..."
          echo "Registry: $ECR_REGISTRY"
          echo "Image tag: $IMAGE_TAG"
          
          # Build image
          docker build \
            -f backend/Dockerfile \
            -t $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:latest \
            ./backend
          
          # Push to ECR
          echo "ğŸ“¤ Pushing Backend image to ECR..."
          docker push $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:latest
          
          # Output image URL
          IMAGE_URL="$ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG"
          echo "image=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "âœ… Backend image: $IMAGE_URL"
          
          # Debug: Verify the output
          cat $GITHUB_OUTPUT | grep "image="

      - name: Image Build Summary
        run: |
          echo "ğŸ“¦ ================================"
          echo "ğŸ“¦ DOCKER IMAGES BUILT"
          echo "ğŸ“¦ ================================"
          echo ""
          echo "Frontend: ${{ steps.build-frontend.outputs.image }}"
          echo "Backend: ${{ steps.build-backend.outputs.image }}"
          echo ""
          echo "Verifying outputs are set..."
          if [ -z "${{ steps.build-frontend.outputs.image }}" ]; then
            echo "âŒ ERROR: Frontend image output is empty!"
            exit 1
          fi
          if [ -z "${{ steps.build-backend.outputs.image }}" ]; then
            echo "âŒ ERROR: Backend image output is empty!"
            exit 1
          fi
          echo "âœ… All outputs are valid"

  # ==================== DEPLOY FRONTEND ====================
  deploy-frontend:
    name: Deploy Frontend Container
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Construct Image URLs
        id: image-urls
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="$AWS_ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          FRONTEND_IMAGE="$ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}"
          echo "frontend_image=$FRONTEND_IMAGE" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Frontend Image: $FRONTEND_IMAGE"

      - name: Get IPs
        id: get-ips
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          BACKEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`BackendPrivateIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT
          echo "âœ… Frontend IP: $FRONTEND_IP"
          echo "âœ… Backend IP: $BACKEND_IP"

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY_B64 }}" | base64 -d > ~/.ssh/task-manager-key.pem
          chmod 600 ~/.ssh/task-manager-key.pem
          ssh-keyscan -H ${{ steps.get-ips.outputs.frontend_ip }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Deploy Frontend Container
        env:
          FRONTEND_IMAGE: ${{ steps.image-urls.outputs.frontend_image }}
          BACKEND_IP: ${{ steps.get-ips.outputs.backend_ip }}
        run: |
          echo "ğŸš€ Deploying Frontend container..."
          echo "ğŸ“¦ Frontend Image: $FRONTEND_IMAGE"
          echo "ğŸ”— Backend IP: $BACKEND_IP"
          
          ssh -i ~/.ssh/task-manager-key.pem \
            -o StrictHostKeyChecking=no \
            ec2-user@${{ steps.get-ips.outputs.frontend_ip }} \
            bash -s "$FRONTEND_IMAGE" "$BACKEND_IP" << 'ENDSSH'
            set -e
            
            FRONTEND_IMAGE="$1"
            BACKEND_IP="$2"
            
            echo "ğŸ” Logging into ECR..."
            aws ecr get-login-password --region us-east-1 | \
              docker login --username AWS --password-stdin $(echo "$FRONTEND_IMAGE" | cut -d'/' -f1)
            
            echo "ğŸ“¥ Pulling Frontend image..."
            docker pull $FRONTEND_IMAGE
            
            echo "ğŸ›‘ Stopping old container..."
            docker stop taskmanager-frontend 2>/dev/null || true
            docker rm taskmanager-frontend 2>/dev/null || true
            
            echo "ğŸš€ Starting new Frontend container..."
            docker run -d \
              --name taskmanager-frontend \
              --restart unless-stopped \
              -p 3000:80 \
              $FRONTEND_IMAGE
            
            sleep 5
            
            if ! docker ps | grep -q taskmanager-frontend; then
              echo "âŒ Container failed to start"
              docker logs taskmanager-frontend
              exit 1
            fi
            
            echo "ğŸ”„ Configuring Nginx..."
            
            # Backup original config
            if [ ! -f /etc/nginx/nginx.conf.original ]; then
              sudo cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.original
            fi
            
            # Create clean main config
            sudo bash -c 'cat > /etc/nginx/nginx.conf' << 'NGINX_MAIN_EOF'
             user nginx;
              worker_processes auto;
              error_log /var/log/nginx/error.log notice;
              pid /run/nginx.pid;

           events {
           worker_connections 1024;
            }

          http {
            include /etc/nginx/mime.types;
             default_type application/octet-stream;
             log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                     '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
                  access_log /var/log/nginx/access.log main;
            sendfile on;
            tcp_nopush on;
            keepalive_timeout 65;
            types_hash_max_size 4096;
           include /etc/nginx/conf.d/*.conf;
             }
             NGINX_MAIN_EOF
            
            # Remove old configs
            sudo rm -f /etc/nginx/conf.d/default.conf
            sudo rm -f /etc/nginx/conf.d/*.disabled
            
            # Create app config
            sudo bash -c "cat > /etc/nginx/conf.d/taskmanager.conf" <<EOF
            upstream frontend_app {
           server localhost:3000;
            }

              upstream backend_app {
           server ${BACKEND_IP}:5000;
             }

          server {
          listen 80 default_server;
           listen [::]:80 default_server;
           server_name _;

           location / {
           proxy_pass http://frontend_app;
              proxy_http_version 1.1;
             proxy_set_header Upgrade \$http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host \$host;
           proxy_cache_bypass \$http_upgrade;
            proxy_set_header X-Real-IP \$remote_addr;
           proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
           proxy_set_header X-Forwarded-Proto \$scheme;
             }

             location /api/ {
           proxy_pass http://backend_app/api/;
           proxy_http_version 1.1;
          proxy_set_header Host \$host;
          proxy_set_header X-Real-IP \$remote_addr;
          proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto \$scheme;
          proxy_connect_timeout 60s;
          proxy_send_timeout 60s;
          proxy_read_timeout 60s;
            }
          }
          EOF
            
            echo "ğŸ§ª Testing Nginx configuration..."
            if ! sudo nginx -t; then
              echo "âŒ Nginx test failed"
              sudo cat /etc/nginx/conf.d/taskmanager.conf
              exit 1
            fi
            
            echo "ğŸ”„ Reloading Nginx..."
            sudo systemctl reload nginx
            sleep 3
            
            echo "ğŸ§ª Testing connectivity..."
            FRONTEND_STATUS=$(curl -s -o /dev/null -w '%{http_code}' http://localhost:3000)
            NGINX_STATUS=$(curl -s -o /dev/null -w '%{http_code}' http://localhost)
            
            echo "âœ… Deployment complete!"
            echo "  Frontend :3000 â†’ HTTP $FRONTEND_STATUS"
            echo "  Nginx :80 â†’ HTTP $NGINX_STATUS"
            
            if [ "$NGINX_STATUS" != "200" ]; then
              echo "âš ï¸ Nginx not returning 200, checking logs..."
              sudo tail -5 /var/log/nginx/error.log
            fi
           ENDSSH

      - name: Verify Frontend Deployment
        run: |
          echo "ğŸ” Verifying Frontend deployment..."
          sleep 10
          
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ steps.get-ips.outputs.frontend_ip }})
          echo "HTTP Status: $STATUS"
          
          if [ "$STATUS" -eq 200 ]; then
            echo "âœ… Frontend is accessible (HTTP $STATUS)"
          else
            echo "âŒ Frontend returned HTTP $STATUS"
            curl -I http://${{ steps.get-ips.outputs.frontend_ip }}
            exit 1
          fi

  # ==================== DEPLOY BACKEND ====================
  deploy-backend:
    name: Deploy Backend Container
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push, deploy-frontend]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get IPs
        id: get-ips
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          
          BACKEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`BackendPrivateIP`].OutputValue' \
            --output text)
          
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY_B64 }}" | base64 -d > ~/.ssh/task-manager-key.pem
          chmod 600 ~/.ssh/task-manager-key.pem
          ssh-keyscan -H ${{ steps.get-ips.outputs.frontend_ip }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Construct Image URLs
        id: image-urls
        run: |
          # Get ECR registry from AWS account
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="$AWS_ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          
          # Construct backend image URL
          BACKEND_IMAGE="$ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}"
          
          echo "backend_image=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Backend Image: $BACKEND_IMAGE"

      - name: Deploy Backend Container
        env:
          BACKEND_IMAGE: ${{ steps.image-urls.outputs.backend_image }}
          BACKEND_IP: ${{ steps.get-ips.outputs.backend_ip }}
          FRONTEND_IP: ${{ steps.get-ips.outputs.frontend_ip }}
        run: |
          echo "ğŸš€ Deploying Backend container..."
          echo "ğŸ“¦ Backend Image: $BACKEND_IMAGE"
          echo "ğŸ”— Backend IP: $BACKEND_IP"
          
          if [ -z "$BACKEND_IMAGE" ]; then
            echo "âŒ Backend image URL is empty!"
            exit 1
          fi
          
          # Copy SSH key to Frontend (bastion)
          scp -i ~/.ssh/task-manager-key.pem \
            ~/.ssh/task-manager-key.pem \
            ec2-user@$FRONTEND_IP:~/.ssh/
          
          # Deploy via Frontend to Backend
          ssh -i ~/.ssh/task-manager-key.pem \
            -o StrictHostKeyChecking=no \
            ec2-user@$FRONTEND_IP << ENDSSH
            set -e
            
            chmod 600 ~/.ssh/task-manager-key.pem
            
            # Deploy to Backend via SSH
            ssh -i ~/.ssh/task-manager-key.pem \
              -o StrictHostKeyChecking=no \
              ec2-user@$BACKEND_IP << 'BACKEND_EOF'
              set -e
              
              echo "ğŸ” Logging into ECR..."
              aws ecr get-login-password --region us-east-1 | \
                docker login --username AWS --password-stdin \$(echo "$BACKEND_IMAGE" | cut -d'/' -f1)
              
              echo "ğŸ“¥ Pulling Backend image: $BACKEND_IMAGE"
              docker pull $BACKEND_IMAGE
              
              echo "ğŸ›‘ Stopping old container..."
              docker stop taskmanager-backend 2>/dev/null || true
              docker rm taskmanager-backend 2>/dev/null || true
              
              echo "ğŸš€ Starting new Backend container..."
              docker run -d \
                --name taskmanager-backend \
                --restart unless-stopped \
                -p 5000:5000 \
                -e DB_HOST=localhost \
                -e DB_USER=taskuser \
                -e DB_PASSWORD=TaskManager2025! \
                -e DB_NAME=taskmanager \
                --network host \
                $BACKEND_IMAGE
              
              echo "â³ Waiting for backend to start..."
              sleep 10
              
              # Verify container is running
              if ! docker ps | grep -q taskmanager-backend; then
                echo "âŒ Backend container failed to start"
                docker logs taskmanager-backend
                exit 1
              fi
              
              echo "âœ… Backend container deployed!"
              docker ps | grep taskmanager-backend
              
              # Test backend health locally
              echo "ğŸ§ª Testing backend health..."
              HEALTH_STATUS=\$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/api/health || echo "000")
              echo "Backend health check status: \$HEALTH_STATUS"
              
              if [ "\$HEALTH_STATUS" = "200" ]; then
                echo "âœ… Backend is healthy!"
                curl -s http://localhost:5000/api/health | head -5
              else
                echo "âš ï¸ Backend health check failed (HTTP \$HEALTH_STATUS)"
                echo "Container logs:"
                docker logs taskmanager-backend | tail -20
              fi
          BACKEND_EOF
          ENDSSH

      - name: Verify Backend Deployment
        run: |
          echo "ğŸ” Verifying Backend deployment..."
          sleep 5
          
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            http://${{ steps.get-ips.outputs.frontend_ip }}/api/health)
          
          if [ "$STATUS" -eq 200 ]; then
            echo "âœ… Backend is healthy (HTTP $STATUS)"
          else
            echo "âš ï¸ Backend returned HTTP $STATUS"
          fi

  # ==================== DEPLOYMENT SUMMARY ====================
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push, deploy-frontend, deploy-backend]
    if: always() && needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Frontend IP
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT

      - name: Display Summary
        env:
          FRONTEND_IMAGE: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}
          BACKEND_IMAGE: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}
        run: |
          echo ""
          echo "ğŸ‰ ================================"
          echo "ğŸ‰ DEPLOYMENT COMPLETE"
          echo "ğŸ‰ ================================"
          echo ""
          echo "ğŸ“¦ Docker Images:"
          echo "   Frontend: $FRONTEND_IMAGE"
          echo "   Backend: $BACKEND_IMAGE"
          echo ""
          echo "ğŸŒ Application URLs:"
          echo "   Frontend: http://${{ steps.get-ip.outputs.frontend_ip }}"
          echo "   API Health: http://${{ steps.get-ip.outputs.frontend_ip }}/api/health"
          echo "   API Tasks: http://${{ steps.get-ip.outputs.frontend_ip }}/api/tasks"
          echo ""
          echo "ğŸ“Š Deployment Status:"
          echo "   Build & Push: ${{ needs.build-and-push.result }}"
          echo "   Frontend Deploy: ${{ needs.deploy-frontend.result }}"
          echo "   Backend Deploy: ${{ needs.deploy-backend.result }}"
          echo ""
          
          if [[ "${{ needs.deploy-frontend.result }}" == "success" ]] && \
             [[ "${{ needs.deploy-backend.result }}" == "success" ]]; then
            echo "âœ… All deployments successful!"
          else
            echo "âš ï¸ Some deployments failed. Check logs above."
          fi