name: CD - Deploy to AWS with Docker

on:
  push:
    branches: [main]
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ENVIRONMENT_NAME: TaskManager
  FRONTEND_IMAGE_NAME: taskmanager-frontend
  BACKEND_IMAGE_NAME: taskmanager-backend

jobs:
  check-deployment:
    name: Check if Deployment Needed
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Check deployment condition
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment triggered by push to main"
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.pull_request.merged }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment triggered by merged PR"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment triggered manually"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "‚è∏Ô∏è  Deployment skipped"
          fi

  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [check-deployment]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    outputs:
      ecr_registry: ${{ steps.login-ecr.outputs.registry }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get Frontend IP for build
        id: get-ip
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "Frontend IP: $FRONTEND_IP"

      - name: Build Frontend Docker Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üî® Building Frontend Docker image..."
          docker build \
            -f frontend/Dockerfile \
            --build-arg REACT_APP_API_URL=http://${{ steps.get-ip.outputs.frontend_ip }}/api \
            -t $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:latest \
            ./frontend
          
          echo "üì§ Pushing Frontend image to ECR..."
          docker push $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:latest
          
          echo "‚úÖ Frontend image: $ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG"

      - name: Build Backend Docker Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üî® Building Backend Docker image..."
          docker build \
            -f backend/Dockerfile \
            -t $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:latest \
            ./backend
          
          echo "üì§ Pushing Backend image to ECR..."
          docker push $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:latest
          
          echo "‚úÖ Backend image: $ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG"

  deploy-frontend:
    name: Deploy Frontend Container
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get IPs
        id: get-ips
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' \
            --output text)
          
          BACKEND_IP=$(aws cloudformation describe-stacks \
            --stack-name TaskManager-compute \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`BackendPrivateIP`].OutputValue' \
            --output text)
          
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend IP: $FRONTEND_IP"
          echo "‚úÖ Backend IP: $BACKEND_IP"

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY_B64 }}" | base64 -d > ~/.ssh/task-manager-key.pem
          chmod 600 ~/.ssh/task-manager-key.pem
          ssh-keyscan -H ${{ steps.get-ips.outputs.frontend_ip }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Deploy Frontend Container
        env:
          ECR_REGISTRY: ${{ needs.build-and-push.outputs.ecr_registry }}
          IMAGE_TAG: ${{ github.sha }}
          BACKEND_IP: ${{ steps.get-ips.outputs.backend_ip }}
        run: |
          FRONTEND_IMAGE="$ECR_REGISTRY/${{ env.FRONTEND_IMAGE_NAME }}:$IMAGE_TAG"
          echo "üöÄ Deploying: $FRONTEND_IMAGE"
          
          ssh -i ~/.ssh/task-manager-key.pem \
            -o StrictHostKeyChecking=no \
            ec2-user@${{ steps.get-ips.outputs.frontend_ip }} bash -s <<'ENDSSH'
            set -e
            
            aws ecr get-login-password --region us-east-1 | \
              docker login --username AWS --password-stdin $ECR_REGISTRY
            
            docker pull $FRONTEND_IMAGE
            docker stop taskmanager-frontend 2>/dev/null || true
            docker rm taskmanager-frontend 2>/dev/null || true
            
            docker run -d \
              --name taskmanager-frontend \
              --restart unless-stopped \
              -p 3000:80 \
              $FRONTEND_IMAGE
            
            sudo tee /etc/nginx/conf.d/taskmanager.conf > /dev/null <<'NGINX_EOF'
            upstream frontend { server localhost:3000; }
            upstream backend { server BACKEND_IP_PLACEHOLDER:5000; }
            
            server {
                listen 80;
                location / {
                    proxy_pass http://frontend;
                    proxy_http_version 1.1;
                    proxy_set_header Host $host;
                }
                location /api/ {
                    proxy_pass http://backend/api/;
                    proxy_set_header Host $host;
                }
            }
            NGINX_EOF
            
            sudo sed -i "s/BACKEND_IP_PLACEHOLDER/$BACKEND_IP/g" /etc/nginx/conf.d/taskmanager.conf
            sudo nginx -t && sudo systemctl reload nginx
            echo "‚úÖ Deployed!"
          ENDSSH

      - name: Verify Frontend Deployment
        run: |
          echo "üîç Verifying deployment..."
          sleep 10
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ steps.get-ips.outputs.frontend_ip }})
          if [ "$STATUS" = "200" ]; then
            echo "‚úÖ Frontend accessible (HTTP $STATUS)"
          else
            echo "‚ö†Ô∏è  HTTP $STATUS"
          fi

  deploy-backend:
    name: Deploy Backend Container
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push, deploy-frontend]
    if: needs.check-deployment.outputs.should_deploy == 'true'
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get IPs
        id: get-ips
        run: |
          FRONTEND_IP=$(aws cloudformation describe-stacks --stack-name TaskManager-compute --query 'Stacks[0].Outputs[?OutputKey==`FrontendPublicIP`].OutputValue' --output text)
          BACKEND_IP=$(aws cloudformation describe-stacks --stack-name TaskManager-compute --query 'Stacks[0].Outputs[?OutputKey==`BackendPrivateIP`].OutputValue' --output text)
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY_B64 }}" | base64 -d > ~/.ssh/key.pem
          chmod 600 ~/.ssh/key.pem
          ssh-keyscan -H ${{ steps.get-ips.outputs.frontend_ip }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Deploy Backend
        env:
          ECR_REGISTRY: ${{ needs.build-and-push.outputs.ecr_registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          BACKEND_IMAGE="$ECR_REGISTRY/${{ env.BACKEND_IMAGE_NAME }}:$IMAGE_TAG"
          scp -i ~/.ssh/key.pem ~/.ssh/key.pem ec2-user@${{ steps.get-ips.outputs.frontend_ip }}:~/.ssh/
          
          ssh -i ~/.ssh/key.pem ec2-user@${{ steps.get-ips.outputs.frontend_ip }} bash -s <<ENDSSH
          chmod 600 ~/.ssh/key.pem
          ssh -i ~/.ssh/key.pem -o StrictHostKeyChecking=no ec2-user@${{ steps.get-ips.outputs.backend_ip }} bash -s <<'BACKEND_EOF'
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $ECR_REGISTRY
          docker pull $BACKEND_IMAGE
          docker stop taskmanager-backend 2>/dev/null || true
          docker rm taskmanager-backend 2>/dev/null || true
          docker run -d --name taskmanager-backend --restart unless-stopped -p 5000:5000 \
            -e DB_HOST=localhost -e DB_USER=taskuser -e DB_PASSWORD=TaskManager2025! -e DB_NAME=taskmanager \
            --network host $BACKEND_IMAGE
          sleep 5 && curl -f http://localhost:5000/api/health || echo "‚ö†Ô∏è Check failed"
          BACKEND_EOF
          ENDSSH